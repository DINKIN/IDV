
[ug::head {Jython Library Documentation}]

The IDV comes with a number of Jython libraries that provide a range of facilities.

<h2> Module: grid</h2>
 This is the doc for the grid module 
<hr>
<p><a name="applyToRange"></a><code class="command">applyToRange(function, data):</code><p style="padding:0;margin-left:20;margin-top:0">
Apply the function name to each timestep of the data</p><p><a name="applyToRangeValues"></a><code class="command">applyToRangeValues(function, data):</code><p style="padding:0;margin-left:20;margin-top:0">
Apply the function name to each value in each timestep of the data</p><p><a name="averageOverTime"></a><code class="command">averageOverTime(field, makeTimes):</code><p style="padding:0;margin-left:20;margin-top:0">
Average the values in each time step
If makeTimes is true (1) then we return a field mapping all of the times
to the average. Else we just return the average</p><p><a name="combineFields"></a><code class="command">combineFields():</code><p style="padding:0;margin-left:20;margin-top:0">
combine several fields together</p><p><a name="extractLatitudeFromNWPGrid"></a><code class="command">extractLatitudeFromNWPGrid(fieldimpl):</code><p style="padding:0;margin-left:20;margin-top:0">
Get the latitude coordinate from a grid.  Return a grid
of the latitudes at each point.</p><p><a name="extractPressureFromNWPGrid"></a><code class="command">extractPressureFromNWPGrid(fieldimpl):</code><p style="padding:0;margin-left:20;margin-top:0">
Get the pressure coordinate from a time series grid and
return a grid of the pressure at all points.  Input
grid must have pressure or height (which is converted
to pressure in the standard atmosphere).
User must be sure input is a suitable FlatField.</p><p><a name="getAltitude"></a><code class="command">getAltitude(z):</code><p style="padding:0;margin-left:20;margin-top:0">
Change units from geopotential meters to meters</p><p><a name="getNthTimeGrid"></a><code class="command">getNthTimeGrid(fieldimpl, Nth):</code><p style="padding:0;margin-left:20;margin-top:0">
Get the Nth grid in time series of grids;
User must be sure input is a suitable data field.
returns a single time.
Nth is an integer, >=0, <= max index of grid time series.</p><p><a name="getSliceAtAltitude"></a><code class="command">getSliceAtAltitude(fieldimpl, alt, unit):</code><p style="padding:0;margin-left:20;margin-top:0">
Extract a 2D horizontal slice from a 3D grid at the given altitude;
level is a real number; if unit is supplied, it must
be compatible with meters (ft, fathoms, etc)
param fieldimpl is a grid which may have
one or more time steps.</p><p><a name="getSliceAtLevel"></a><code class="command">getSliceAtLevel(fieldimpl, level):</code><p style="padding:0;margin-left:20;margin-top:0">
Extract a 2D horizontal slice from a 3D grid at "Level."
level is a real number; must be appropriate for the grid.
param fieldimpl is a grid which may have one or more time steps.</p><p><a name="horizontalAdvection"></a><code class="command">horizontalAdvection(param, u, v):</code><p style="padding:0;margin-left:20;margin-top:0">
horizontal advection</p><p><a name="horizontalDivergence"></a><code class="command">horizontalDivergence(param, u, v):</code><p style="padding:0;margin-left:20;margin-top:0">
horizontal flux divergence</p><p><a name="layerAverage"></a><code class="command">layerAverage(grid, top, bottom):</code><p style="padding:0;margin-left:20;margin-top:0">
Wrapper for calculating layer average</p><p><a name="layerDiff"></a><code class="command">layerDiff(grid, top, bottom):</code><p style="padding:0;margin-left:20;margin-top:0">
Wrapper for calculating layer difference</p><p><a name="make2D"></a><code class="command">make2D(slice):</code><p style="padding:0;margin-left:20;margin-top:0">
Make a 2D slice from a 3D slice at a single level</p><p><a name="makeFlowField"></a><code class="command">makeFlowField(a, b, c):</code><p style="padding:0;margin-left:20;margin-top:0">
Make a vector from 3 components
<div class=jython>
makeVector(a,b) = \[a,b,c\]
</div></p><p><a name="makeTimeSequence"></a><code class="command">makeTimeSequence(g):</code><p style="padding:0;margin-left:20;margin-top:0">
Merge a set of single time grids/images into a time sequence</p><p><a name="makeTrueVector"></a><code class="command">makeTrueVector(u, v):</code><p style="padding:0;margin-left:20;margin-top:0">
true wind vectors</p><p><a name="makeVector"></a><code class="command">makeVector(a, b):</code><p style="padding:0;margin-left:20;margin-top:0">
Make a vector from 2 components
<div class=jython>
makeVector(a,b) = \[a,b\]
</div></p><p><a name="newName"></a><code class="command">newName(field, varname, copy):</code><p style="padding:0;margin-left:20;margin-top:0">
create a new field with a new parameter name</p><p><a name="newUnit"></a><code class="command">newUnit(field, varname, unitname):</code><p style="padding:0;margin-left:20;margin-top:0">
set the name and unit on a grid</p><p><a name="resampleGrid"></a><code class="command">resampleGrid(oldGrid, gridwithNewDomain):</code><p style="padding:0;margin-left:20;margin-top:0">
display gridded data on a new domain</p><p><a name="windShear"></a><code class="command">windShear(u, v, z, top, bottom):</code><p style="padding:0;margin-left:20;margin-top:0">
calculate the wind shear between discrete layers
<div class=jython>
shear = sqrt((u(top)-u(bottom))^2 + (v(top)-v(bottom))^2)/zdiff</pre>
</div></p><p><a name="windShearVector"></a><code class="command">windShearVector(u, v, top, bottom):</code><p style="padding:0;margin-left:20;margin-top:0">
calculate the u and v layer difference and return as vector</p>
<h2> Module: griddiag</h2>
 
   This is the doc for the Grid Diagnostics module.  These functions
   are based on the grid diagnostics from the GEneral Meteorological 
   PAcKage (GEMPAK).  Note that the names are case sensitive and some
   are named slightly different from GEMPAK functions.
   <P>
   In the following operators, scalar operands are named Si and 
   vector operands are named Vi.  Lowercase u and v refer to the
   grid relative components of a vector.

<hr>
<p><a name="add"></a><code class="command">add(S1, S2):</code><p style="padding:0;margin-left:20;margin-top:0">
Addition
<div class=jython>
ADD  (S1, S2) = S1 + S2
</div></p><p><a name="adv"></a><code class="command">adv(S, V):</code><p style="padding:0;margin-left:20;margin-top:0">
Horizontal Advection, negative by convention
<div class=jython>
ADV ( S, V ) = - ( u * DDX (S) + v * DDY (S) )
</div></p><p><a name="age"></a><code class="command">age(obs, geo):</code><p style="padding:0;margin-left:20;margin-top:0">
Ageostrophic wind
<div class=jython>
AGE ( S ) = \[ u (OBS) - u (GEO(S)), v (OBS) - v (GEO(S)) \]
</div></p><p><a name="atn2"></a><code class="command">atn2(S1, S2):</code><p style="padding:0;margin-left:20;margin-top:0">
Wrapper for atan2 built-in
<div class=jython>
ATN2 (S1, S2) = ATAN ( S1 / S2 )
</div></p><p><a name="avg"></a><code class="command">avg(S1, S2):</code><p style="padding:0;margin-left:20;margin-top:0">
Average of 2 scalars
<div class=jython>
AVG  (S1, S2) = ( S1 + S2 ) / 2
</div></p><p><a name="avor"></a><code class="command">avor(V):</code><p style="padding:0;margin-left:20;margin-top:0">
Absolute Vorticity
<div class=jython>
AVOR ( V ) = VOR ( V ) + CORL(V)
</div></p><p><a name="corl"></a><code class="command">corl(S):</code><p style="padding:0;margin-left:20;margin-top:0">
Coriolis Parameter for all points in a grid
<div class=jython>
CORL = TWO_OMEGA*sin(latr)
</div></p><p><a name="cros"></a><code class="command">cros(V1, V2):</code><p style="padding:0;margin-left:20;margin-top:0">
Vector cross product magnitude
<div class=jython>
CROS ( V1, V2 ) = u1 * v2 - u2 * v1
</div></p><p><a name="ddx"></a><code class="command">ddx(S):</code><p style="padding:0;margin-left:20;margin-top:0">
Take the derivative with respect to the domain's X coordinate</p><p><a name="ddy"></a><code class="command">ddy(S):</code><p style="padding:0;margin-left:20;margin-top:0">
Take the derivative with respect to the domain's Y coordinate</p><p><a name="defr"></a><code class="command">defr(V):</code><p style="padding:0;margin-left:20;margin-top:0">
Total deformation
<div class=jython>
DEF ( V ) = ( STR (V) ** 2 + SHR (V) ** 2 ) ** .5
</div></p><p><a name="div"></a><code class="command">div(V):</code><p style="padding:0;margin-left:20;margin-top:0">
Horizontal Divergence
<div class=jython>
DIV ( V ) = DDX ( u ) + DDY ( v )
</div></p><p><a name="dot"></a><code class="command">dot(V1, V2):</code><p style="padding:0;margin-left:20;margin-top:0">
Vector dot product
<div class=jython>
DOT ( V1, V2 ) = u1 * u2 + v1 * v2
</div></p><p><a name="dvdx"></a><code class="command">dvdx(V):</code><p style="padding:0;margin-left:20;margin-top:0">
Partial x derivative of a vector
<div class=jython>
DVDX ( V ) = \[ DDX (u), DDX (v) \]
</div></p><p><a name="dvdy"></a><code class="command">dvdy(V):</code><p style="padding:0;margin-left:20;margin-top:0">
Partial x derivative of a vector
<div class=jython>
DVDY ( V ) = \[ DDY (u), DDY (v) \]
</div></p><p><a name="geo"></a><code class="command">geo(z):</code><p style="padding:0;margin-left:20;margin-top:0">
geostrophic wind from height
<div class=jython>
GEO ( S )  = \[ - DDY (S) * const / CORL, DDX (S) * const / CORL \]
</div></p><p><a name="grad"></a><code class="command">grad(S):</code><p style="padding:0;margin-left:20;margin-top:0">
Gradient of a scalar
<div class=jython>
GRAD ( S ) = \[ DDX ( S ), DDY ( S ) \]
</div></p><p><a name="inad"></a><code class="command">inad(V1, V2):</code><p style="padding:0;margin-left:20;margin-top:0">
Inertial advective wind
<div class=jython>
INAD ( V1, V2 ) = \[ DOT ( V1, GRAD (u2) ),
DOT ( V1, GRAD (v2) ) \]
</div></p><p><a name="jcbn"></a><code class="command">jcbn(S1, S2):</code><p style="padding:0;margin-left:20;margin-top:0">
Jacobian Determinant
<div class=jython>
JCBN ( S1, S2 ) = DDX (S1) * DDY (S2) - DDY (S1) * DDX (S2)
</div></p><p><a name="lap"></a><code class="command">lap(S):</code><p style="padding:0;margin-left:20;margin-top:0">
Laplacian operator
<div class=jython>
LAP ( S ) = DIV ( GRAD (S) )
</div></p><p><a name="latr"></a><code class="command">latr(S):</code><p style="padding:0;margin-left:20;margin-top:0">
Latitudue all points in a grid</p><p><a name="lav"></a><code class="command">lav(S, level1, level2):</code><p style="padding:0;margin-left:20;margin-top:0">
Layer Average
<div class=jython>
LAV ( S ) = ( S (level1) + S (level2) ) / 2.
</div></p><p><a name="ldf"></a><code class="command">ldf(S, level1, level2):</code><p style="padding:0;margin-left:20;margin-top:0">
Layer Average
<div class=jython>
LDF ( S ) = S (level1) - S (level2)
</div></p><p><a name="mag"></a><code class="command">mag():</code><p style="padding:0;margin-left:20;margin-top:0">
Magnitude of a vector</p><p><a name="mixr"></a><code class="command">mixr(temp, rh):</code><p style="padding:0;margin-left:20;margin-top:0">
Mixing Ratio from Temperature, RH (requires pressure domain)</p><p><a name="mul"></a><code class="command">mul(S1, S2):</code><p style="padding:0;margin-left:20;margin-top:0">
Multiply
<div class=jython>
MUL  (S1, S2) = S1 * S2
</div></p><p><a name="quo"></a><code class="command">quo(S1, S2):</code><p style="padding:0;margin-left:20;margin-top:0">
Divide
<div class=jython>
QUO  (S1, S2) = S1 / S2
</div></p><p><a name="qvec"></a><code class="command">qvec(S, V):</code><p style="padding:0;margin-left:20;margin-top:0">
Q-vector at a level ( K / m / s )
<div class=jython>
QVEC ( S, V ) = \[ - ( DOT ( DVDX (V), GRAD (S) ) ),
- ( DOT ( DVDY (V), GRAD (S) ) ) \]
where S can be any thermal paramenter, usually THTA.
</div></p><p><a name="sdiv"></a><code class="command">sdiv(S, V):</code><p style="padding:0;margin-left:20;margin-top:0">
Horizontal Flux Divergence
<div class=jython>
SDIV ( S, V ) = S * DIV ( V ) + DOT ( V, GRAD ( S ) )
</div></p><p><a name="shr"></a><code class="command">shr(V):</code><p style="padding:0;margin-left:20;margin-top:0">
Shear Deformation
<div class=jython>
SHR ( V ) = DDX ( v ) + DDY ( u )
</div></p><p><a name="str"></a><code class="command">str(V):</code><p style="padding:0;margin-left:20;margin-top:0">
Stretching Deformation
<div class=jython>
STR ( V ) = DDX ( u ) - DDY ( v )
</div></p><p><a name="sub"></a><code class="command">sub(S1, S2):</code><p style="padding:0;margin-left:20;margin-top:0">
Subtract
<div class=jython>
SUB  (S1, S2) = S1 - S2
</div></p><p><a name="thrm"></a><code class="command">thrm(S, level1, level2):</code><p style="padding:0;margin-left:20;margin-top:0">
Thermal wind
<div class=jython>
THRM ( S ) = \[ u (GEO(S)) (level1) - u (GEO(S)) (level2),
v (GEO(S)) (level1) - v (GEO(S)) (level2) \]
</div></p><p><a name="thta"></a><code class="command">thta(temp):</code><p style="padding:0;margin-left:20;margin-top:0">
Potential Temperature from Temperature (requires pressure domain)</p><p><a name="thte"></a><code class="command">thte(temp, rh):</code><p style="padding:0;margin-left:20;margin-top:0">
Equivalent Potential Temperature from Temperature and Relative
humidity (requires pressure domain)</p><p><a name="un"></a><code class="command">un(V):</code><p style="padding:0;margin-left:20;margin-top:0">
North relative u component</p><p><a name="ur"></a><code class="command">ur(V):</code><p style="padding:0;margin-left:20;margin-top:0">
Grid relative u component</p><p><a name="vadd"></a><code class="command">vadd(V1, V2):</code><p style="padding:0;margin-left:20;margin-top:0">
add the components of 2 vectors
<div class=jython>
VADD (V1, V2) = \[ u1+u2, v1+v2 \]
</div></p><p><a name="vecr"></a><code class="command">vecr(S1, S2):</code><p style="padding:0;margin-left:20;margin-top:0">
Make a vector from two components
<div class=jython>
VECR ( S1, S2 ) = \[ S1, S2 \]
</div></p><p><a name="vlav"></a><code class="command">vlav(V, level1, level2):</code><p style="padding:0;margin-left:20;margin-top:0">
calculate the vector layer average
<div class=jython>
VLDF(V) = \[(u(level1) - u(level2))/2,
(v(level1) - v(level2))/2\]
</div></p><p><a name="vldf"></a><code class="command">vldf(V, level1, level2):</code><p style="padding:0;margin-left:20;margin-top:0">
calculate the vector layer difference
<div class=jython>
VLDF(V) = \[u(level1) - u(level2),
v(level1) - v(level2)\]
</div></p><p><a name="vmul"></a><code class="command">vmul(V1, V2):</code><p style="padding:0;margin-left:20;margin-top:0">
Multiply the components of 2 vectors
<div class=jython>
VMUL (V1, V2) = \[ u1*u2, v1*v2 \]
</div></p><p><a name="vn"></a><code class="command">vn(V):</code><p style="padding:0;margin-left:20;margin-top:0">
North relative v component</p><p><a name="vor"></a><code class="command">vor(V):</code><p style="padding:0;margin-left:20;margin-top:0">
Relative Vorticity
<div class=jython>
VOR ( V ) = DDX ( v ) - DDY ( u )
</div></p><p><a name="vquo"></a><code class="command">vquo(V1, V2):</code><p style="padding:0;margin-left:20;margin-top:0">
Divide the components of 2 vectors
<div class=jython>
VQUO (V1, V2) = \[ u1/u2, v1/v2 \]
</div></p><p><a name="vr"></a><code class="command">vr(V):</code><p style="padding:0;margin-left:20;margin-top:0">
Grid relative v component</p><p><a name="vsub"></a><code class="command">vsub(V1, V2):</code><p style="padding:0;margin-left:20;margin-top:0">
subtract the components of 2 vectors
<div class=jython>
VSUB (V1, V2) = \[ u1-u2, v1-v2 \]
</div></p>
<h2> Module: image</h2>
<hr>
<p><a name="combineRGB"></a><code class="command">combineRGB(red, green, blue):</code><p style="padding:0;margin-left:20;margin-top:0">
combine 3 images as an RGB image</p><p><a name="makeNavigatedImage"></a><code class="command">makeNavigatedImage(d, ulLat, ulLon, lrLat, lrLon):</code><p style="padding:0;margin-left:20;margin-top:0">
This takes a image data object and a lat/lon bounding box
and adds a lat/lon domain to the data. Use it in conjunction with a formula:</p>
<h2> Module: maps</h2>
<hr>
<p><a name="averageFromMap"></a><code class="command">averageFromMap(field, mapSets):</code><p style="padding:0;margin-left:20;margin-top:0">
</p><p><a name="averageRangeFromMap"></a><code class="command">averageRangeFromMap(range, timeStep, mapSets):</code><p style="padding:0;margin-left:20;margin-top:0">
</p><p><a name="filterMaps"></a><code class="command">filterMaps(mapSets, propName, operator, value):</code><p style="padding:0;margin-left:20;margin-top:0">
</p><p><a name="getMapProperty"></a><code class="command">getMapProperty(polygon, propName):</code><p style="padding:0;margin-left:20;margin-top:0">
Get the named property from the given mapData</p><p><a name="getMapsWithProperty"></a><code class="command">getMapsWithProperty(mapSets, propName, value):</code><p style="padding:0;margin-left:20;margin-top:0">
Return a new set of maps that have the given property value</p><p><a name="make3DMap"></a><code class="command">make3DMap(map, topo):</code><p style="padding:0;margin-left:20;margin-top:0">
Make a 3d map    map -  map line data - topo - topography dataset</p><p><a name="makeFieldFromMapBounds"></a><code class="command">makeFieldFromMapBounds(mapSets, length1, length2, fill, unit):</code><p style="padding:0;margin-left:20;margin-top:0">
</p><p><a name="subsetFromMap"></a><code class="command">subsetFromMap(field, mapSets, fillValue, inverse):</code><p style="padding:0;margin-left:20;margin-top:0">
</p><p><a name="subsetRangeFromMap"></a><code class="command">subsetRangeFromMap(range, timeStep, mapSets, fillValue, inverse):</code><p style="padding:0;margin-left:20;margin-top:0">
</p><p><a name="subsetRangeWithProperty"></a><code class="command">subsetRangeWithProperty(range, mapSets):</code><p style="padding:0;margin-left:20;margin-top:0">
</p><p><a name="subsetWithProperty"></a><code class="command">subsetWithProperty(field, mapSets):</code><p style="padding:0;margin-left:20;margin-top:0">
</p>
<h2> Module: misc</h2>
A set of miscellaneou utilities. 
<hr>
<p><a name="idveval"></a><code class="command">idveval(formula):</code><p style="padding:0;margin-left:20;margin-top:0">
evaluate a formula</p><p><a name="makeFloatArray"></a><code class="command">makeFloatArray(rows, cols, value):</code><p style="padding:0;margin-left:20;margin-top:0">
A utility to make a 2 dimensional float array filled
with the given value</p>
<h2> Module: shell</h2>
A set of utilities for selecting data and creating displays.
   For use from the Jython shell.
<hr>
<p><a name="api"></a><code class="command">api(object):</code><p style="padding:0;margin-left:20;margin-top:0">
</p><p><a name="clear"></a><code class="command">clear():</code><p style="padding:0;margin-left:20;margin-top:0">
</p><p><a name="createDisplay"></a><code class="command">createDisplay(displayType, data, dataName):</code><p style="padding:0;margin-left:20;margin-top:0">
</p><p><a name="listVars"></a><code class="command">listVars():</code><p style="padding:0;margin-left:20;margin-top:0">
</p><p><a name="makeDataSource"></a><code class="command">makeDataSource(path, type):</code><p style="padding:0;margin-left:20;margin-top:0">
</p><p><a name="printType"></a><code class="command">printType(data):</code><p style="padding:0;margin-left:20;margin-top:0">
</p><p><a name="selectData"></a><code class="command">selectData(name1, name2, name3, name4, name5):</code><p style="padding:0;margin-left:20;margin-top:0">
</p><p><a name="selectDataChoice"></a><code class="command">selectDataChoice(name1, name2, name3, name4, name5):</code><p style="padding:0;margin-left:20;margin-top:0">
</p><p><a name="showLib"></a><code class="command">showLib():</code><p style="padding:0;margin-left:20;margin-top:0">
</p>
<h2> Module: test</h2>
 This is the doc for the test module 
<hr>
<p><a name="changeRange"></a><code class="command">changeRange(d):</code><p style="padding:0;margin-left:20;margin-top:0">
</p><p><a name="testApplyToRange"></a><code class="command">testApplyToRange(d):</code><p style="padding:0;margin-left:20;margin-top:0">
</p><p><a name="testApplyToRange2"></a><code class="command">testApplyToRange2(r):</code><p style="padding:0;margin-left:20;margin-top:0">
</p>

[ug::foot]


